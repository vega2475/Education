/**
 * Пример - 2 потока пишут в одну переменную
 * Метод join() - позволяет дождаться завершения потоков прежде чем поток main продолжит выполнять свои инструкции.
 * Но после применения методов join() переменная все равно не дает результат 20000 как должна.
 * Это возникает из-за Race Condition. В нашем случае это из-за того что операция inc не атомарна.
 * Для исправления RC существует кл слово synchronized.
 * Это кл слово синхронизирует работу 2+ потоков.
 * Synchronized можно писать только в сигнатуре метода.
 * Принцип работы synchronized - только один поток получает доступ в один момент времени к выполнению кода в теле метода.
 * Т.е. - если мы пишем synchronized, то мы говорим что только один поток может выполнять этот метод в один момент времени.
 * В Java каждому объекту присваивается монитор (mutex). И этот монитор в один момент времени может быть только у одного потока.
 * Synchronized использует эту особенность java (только один поток в один момент времени может завладеть монитором объекта).
 * Монитор нужен чтобы поток мог получить доступ к методам и полям объекта.
 * Удобно представлять монитор как id захватившего его объекта. Если этот id равен 0 – ресурс свободен. Если не 0 – ресурс занят. Можно встать в очередь и ждать его освобождения.
 */

/*
    В Java у каждого экземпляра объекта есть монитор, который контролируется непосредственно виртуальной машиной.
    Используется он так: любой нестатический synchronized-метод при своем вызове прежде всего пытается захватить
    монитор того объекта, у которого он вызван (на который он может сослаться как на this). Если это удалось – метод исполняется.
    Если нет – поток останавливается и ждет, пока монитор будет отпущен.
    Не указывая объекты явно, мы синхронизируемся на объекте this.
 */

package Multithreading.Synchronized.Part1;

class Main {
    private int counter;

    public static void main(String[] args) throws InterruptedException {
        Main main = new Main();
        main.doWork();

    }

    synchronized void increment(){ //синхронизировали метод
        counter++;
    }

    public void doWork() throws InterruptedException {
        Thread thread1 = new Thread(() -> {
            for(int i = 0; i < 10000; i++){
                increment();
                //counter++;
            }
        });
        Thread thread2 = new Thread(() -> {
            for(int i = 0; i < 10000; i++){
                increment();
                //counter++;
            }
        });
        thread1.start();
        thread2.start();

        thread1.join();
        thread2.join();
        System.out.println(counter);
    }
}
